<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolyCore Tetris</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 { margin-bottom: 20px; color: #00d4ff; text-shadow: 0 0 10px rgba(0, 212, 255, 0.5); }
        .container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; max-width: 1400px; }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .connection-panel { width: 280px; }
        .game-panel { min-width: 450px; }
        .chat-panel { width: 280px; }

        h2 { color: #00d4ff; margin-bottom: 15px; font-size: 1.1em; border-bottom: 1px solid rgba(255, 255, 255, 0.2); padding-bottom: 10px; }
        h3 { color: #aaa; margin: 10px 0 5px 0; font-size: 0.9em; }

        .form-group { margin-bottom: 12px; }
        label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.85em; }

        input[type="text"], input[type="number"] {
            width: 100%; padding: 8px; border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px; background: rgba(0, 0, 0, 0.3); color: #fff; font-size: 14px;
        }
        input:focus { outline: none; border-color: #00d4ff; }

        button { padding: 8px 16px; border: none; border-radius: 5px; cursor: pointer; font-size: 13px; transition: all 0.2s; margin: 3px; }
        .btn-primary { background: #00d4ff; color: #1a1a2e; }
        .btn-primary:hover { background: #00a8cc; }
        .btn-secondary { background: #6c757d; color: #fff; }
        .btn-danger { background: #dc3545; color: #fff; }
        .btn-game { background: #28a745; color: #fff; min-width: 60px; height: 36px; font-size: 11px; }
        .btn-game:hover { background: #218838; }
        .btn-game.drop { background: #fd7e14; min-width: 90px; }
        .btn-game.hold { background: #6f42c1; min-width: 90px; }
        .btn-start { background: #17a2b8; color: #fff; width: 100%; font-size: 15px; padding: 12px; }

        .status { padding: 8px; border-radius: 5px; margin-bottom: 12px; text-align: center; font-size: 0.9em; }
        .status.connected { background: rgba(40, 167, 69, 0.3); border: 1px solid #28a745; }
        .status.disconnected { background: rgba(220, 53, 69, 0.3); border: 1px solid #dc3545; }
        .status.waiting { background: rgba(255, 193, 7, 0.3); border: 1px solid #ffc107; }
        .status.playing { background: rgba(23, 162, 184, 0.3); border: 1px solid #17a2b8; }

        .game-area { display: flex; gap: 10px; align-items: flex-start; justify-content: center; }
        .side-panel { display: flex; flex-direction: column; gap: 10px; min-width: 110px; }

        .preview-box, .stats-box { background: rgba(0, 0, 0, 0.4); padding: 8px; border-radius: 5px; text-align: center; }
        .preview-box h4, .stats-box h4 { color: #888; font-size: 0.75em; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px; }
        .stats-box .value { font-size: 1.4em; font-weight: bold; color: #ffd700; text-shadow: 0 0 8px rgba(255, 215, 0, 0.5); }

        .preview-grid { display: grid; grid-template-columns: repeat(5, 18px); grid-template-rows: repeat(5, 18px); gap: 1px; background: #000; padding: 2px; border-radius: 3px; margin: 0 auto; width: fit-content; }
        .preview-cell { width: 18px; height: 18px; background: #1a1a2e; border-radius: 1px; }

        .board-wrapper { position: relative; }
        .game-board { display: grid; grid-template-columns: repeat(10, 24px); grid-template-rows: repeat(20, 24px); gap: 1px; background: #000; padding: 4px; border-radius: 5px; }
        .cell { width: 24px; height: 24px; background: #1a1a2e; border-radius: 2px; }

        /* Colors */
        .cell.color-1, .preview-cell.color-1 { background: #00d4ff; box-shadow: inset 0 0 4px rgba(255,255,255,0.3); }
        .cell.color-2, .preview-cell.color-2 { background: #1e90ff; box-shadow: inset 0 0 4px rgba(255,255,255,0.3); }
        .cell.color-3, .preview-cell.color-3 { background: #ff8c00; box-shadow: inset 0 0 4px rgba(255,255,255,0.3); }
        .cell.color-4, .preview-cell.color-4 { background: #ffd700; box-shadow: inset 0 0 4px rgba(255,255,255,0.3); }
        .cell.color-5, .preview-cell.color-5 { background: #32cd32; box-shadow: inset 0 0 4px rgba(255,255,255,0.3); }
        .cell.color-6, .preview-cell.color-6 { background: #9932cc; box-shadow: inset 0 0 4px rgba(255,255,255,0.3); }
        .cell.color-7, .preview-cell.color-7 { background: #ff4500; box-shadow: inset 0 0 4px rgba(255,255,255,0.3); }
        .cell.color-8, .preview-cell.color-8 { background: #666; box-shadow: inset 0 0 4px rgba(0,0,0,0.5); }

        .cell.current-piece { box-shadow: inset 0 0 6px rgba(255,255,255,0.5), 0 0 4px rgba(255,255,255,0.3); }
        .cell.ghost { opacity: 0.35; }

        /* Animations */
        @keyframes boardShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            75% { transform: translateX(4px); }
        }
        .board-wrapper.shake { animation: boardShake 0.2s ease-out; }

        @keyframes attackFlash {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: inset 0 0 20px rgba(255, 69, 0, 0.5); }
        }
        .game-board.attack-flash { animation: attackFlash 0.3s ease-out; }

        @keyframes pointsPop {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .stats-box.pop .value { animation: pointsPop 0.25s ease-out; }

        @keyframes floatUp {
            0% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -40px); }
        }
        .float-text {
            position: absolute; left: 50%; top: 40%;
            font-weight: bold; font-size: 1.3em; pointer-events: none; z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: floatUp 0.7s ease-out forwards;
        }
        .float-text.attack { color: #ff4500; }
        .float-text.points { color: #ffd700; }
        .float-text.tetris { color: #00d4ff; font-size: 1.6em; }

        .garbage-indicator {
            position: absolute; right: -20px; top: 4px; bottom: 4px;
            width: 12px; background: rgba(0,0,0,0.4); border-radius: 3px; overflow: hidden;
        }
        .garbage-indicator .fill {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: linear-gradient(to top, #ff4500, #ff6347);
            transition: height 0.3s ease-out; border-radius: 2px;
        }
        .garbage-indicator .count {
            position: absolute; bottom: 2px; left: 0; right: 0;
            text-align: center; font-size: 9px; font-weight: bold;
            color: #fff; text-shadow: 1px 1px 2px #000;
        }

        .controls { display: flex; flex-direction: column; align-items: center; gap: 4px; margin-top: 12px; }
        .controls-row { display: flex; gap: 4px; flex-wrap: wrap; justify-content: center; }

        #log { height: 120px; overflow-y: auto; background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 5px; font-family: monospace; font-size: 10px; }
        .log-entry { margin-bottom: 2px; padding: 2px 4px; border-radius: 2px; }
        .log-sent { background: rgba(0, 212, 255, 0.2); border-left: 2px solid #00d4ff; }
        .log-received { background: rgba(40, 167, 69, 0.2); border-left: 2px solid #28a745; }
        .log-error { background: rgba(220, 53, 69, 0.2); border-left: 2px solid #dc3545; }
        .log-info { background: rgba(255, 193, 7, 0.2); border-left: 2px solid #ffc107; }

        #chatMessages { height: 180px; overflow-y: auto; background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 5px; margin-bottom: 8px; }
        .chat-message { margin-bottom: 4px; padding: 4px 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; word-wrap: break-word; font-size: 0.9em; }
        .chat-message.attack { background: rgba(255, 69, 0, 0.2); border-left: 3px solid #ff4500; }

        #rooms { max-height: 100px; overflow-y: auto; background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 5px; margin-bottom: 12px; }
        .room-item { padding: 6px; margin-bottom: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }

        .players-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
        .player-board { text-align: center; }
        .player-name { margin-bottom: 4px; font-weight: bold; font-size: 1em; }
        .player-name.dead { color: #dc3545; text-decoration: line-through; }
        .player-score { margin-bottom: 8px; font-size: 0.9em; color: #ffd700; }

        .player-board.compact .game-board { grid-template-columns: repeat(10, 16px); grid-template-rows: repeat(20, 16px); }
        .player-board.compact .cell { width: 16px; height: 16px; }
        .player-board.compact .preview-grid { grid-template-columns: repeat(5, 12px); grid-template-rows: repeat(5, 12px); }
        .player-board.compact .preview-cell { width: 12px; height: 12px; }
        .player-board.compact .side-panel { min-width: 75px; }
        .player-board.compact .stats-box .value { font-size: 1.1em; }
        .player-board.compact .garbage-indicator { width: 8px; right: -12px; }

        .hidden { display: none; }
        .key-hint { background: rgba(0,0,0,0.4); padding: 1px 3px; border-radius: 2px; font-size: 0.7em; margin-left: 2px; }
        .controls-info { margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 5px; font-size: 0.8em; color: #888; text-align: center; }
        .controls-info code { background: rgba(255,255,255,0.1); padding: 1px 4px; border-radius: 2px; }

        .scoreboard { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; }
        .scoreboard-entry { padding: 8px 15px; background: rgba(255,255,255,0.1); border-radius: 5px; text-align: center; min-width: 100px; }
        .scoreboard-entry.first { background: rgba(255, 215, 0, 0.3); border: 1px solid #ffd700; }
        .scoreboard-entry .name { font-weight: bold; font-size: 0.9em; }
        .scoreboard-entry .score { color: #ffd700; font-size: 1.2em; font-weight: bold; }
        .scoreboard-entry.dead .name { text-decoration: line-through; color: #dc3545; }
    </style>
</head>
<body>
<h1>üéÆ PolyCore Tetris</h1>

<div class="container">
    <div class="panel connection-panel">
        <h2>üîå Connection</h2>
        <div id="connectionStatus" class="status disconnected">Disconnected</div>
        <div class="form-group"><label>Host</label><input type="text" id="host" value="localhost"></div>
        <div class="form-group"><label>Port</label><input type="number" id="port" value="3091"></div>
        <button id="connectBtn" class="btn-primary" onclick="connect()">Connect</button>
        <button id="disconnectBtn" class="btn-danger hidden" onclick="disconnect()">Disconnect</button>

        <div id="authSection" class="hidden">
            <h2 style="margin-top: 15px;">üë§ Login</h2>
            <div class="form-group"><label>Username</label><input type="text" id="username" placeholder="Enter username" onkeypress="if(event.key==='Enter')authenticate()"></div>
            <button class="btn-primary" onclick="authenticate()">Login</button>
        </div>

        <div id="roomSection" class="hidden">
            <h2 style="margin-top: 15px;">üö™ Rooms</h2>
            <button class="btn-secondary" onclick="showRooms()">Refresh</button>
            <div id="rooms"></div>
            <h3>Create Room</h3>
            <div class="form-group"><label>Room Name</label><input type="text" id="roomName" placeholder="My Room"></div>
            <div class="form-group"><label>Max Players</label><input type="number" id="maxPlayers" value="4" min="1" max="10"></div>
            <button class="btn-primary" onclick="createRoom()">Create</button>
        </div>
    </div>

    <div class="panel game-panel">
        <h2>üéÆ Game</h2>
        <div id="gameInfo" class="status disconnected">Not in a room</div>
        <div id="startSection" class="hidden"><button class="btn-start" onclick="startGame()">‚ñ∂ Start Game</button></div>
        <div class="scoreboard hidden" id="scoreboard"></div>
        <div class="players-container" id="playersContainer"></div>
        <div class="controls" id="gameControls">
            <div class="controls-row">
                <button class="btn-game hold" onclick="sendInput('HOLD')">‚è∏ Hold <span class="key-hint">C</span></button>
                <button class="btn-game" onclick="sendInput('ROTATE')">‚Üª <span class="key-hint">‚Üë</span></button>
            </div>
            <div class="controls-row">
                <button class="btn-game" onclick="sendInput('LEFT')">‚Üê <span class="key-hint">‚Üê</span></button>
                <button class="btn-game" onclick="sendInput('DOWN')">‚Üì <span class="key-hint">‚Üì</span></button>
                <button class="btn-game" onclick="sendInput('RIGHT')">‚Üí <span class="key-hint">‚Üí</span></button>
            </div>
            <div class="controls-row"><button class="btn-game drop" onclick="sendInput('DROP')">‚¨á Drop <span class="key-hint">Space</span></button></div>
        </div>
        <div class="controls-info"><code>‚Üê‚Üí</code> Move <code>‚Üë</code> Rotate <code>‚Üì</code> Soft Drop <code>Space</code> Hard Drop <code>C</code> Hold</div>
    </div>

    <div class="panel chat-panel">
        <h2>üí¨ Chat</h2>
        <div id="chatMessages"></div>
        <div style="display: flex; gap: 4px;">
            <input type="text" id="chatInput" placeholder="/command or message" style="flex: 1;" onkeypress="if(event.key==='Enter')sendChat()">
            <button class="btn-primary" onclick="sendChat()">Send</button>
        </div>
        <h2 style="margin-top: 15px;">üìã Log</h2>
        <div id="log"></div>
    </div>
</div>

<script>
    let socket = null, isAuthenticated = false, currentRoom = null, gameRunning = false, myUsername = null;
    const SHAPE_DIMENSIONS = { 1: 4, 2: 3, 3: 3, 4: 2, 5: 3, 6: 3, 7: 3 };

    let previousStates = {};
    let boardElements = {};
    let pendingGarbage = {};

    function log(msg, type = 'info') {
        const logDiv = document.getElementById('log');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        logDiv.appendChild(entry);
        logDiv.scrollTop = logDiv.scrollHeight;
        while (logDiv.children.length > 80) logDiv.removeChild(logDiv.firstChild);
    }

    function updateStatus(id, status, text) { document.getElementById(id).className = `status ${status}`; document.getElementById(id).textContent = text; }
    function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }
    function formatPoints(points) { return Math.floor(points).toLocaleString(); }

    function connect() {
        const wsUrl = `ws://${document.getElementById('host').value}:${document.getElementById('port').value}/tetris/game`;
        log(`Connecting to ${wsUrl}...`);
        try {
            socket = new WebSocket(wsUrl);
            socket.onopen = () => { log('Connected!'); updateStatus('connectionStatus', 'connected', 'Connected'); document.getElementById('connectBtn').classList.add('hidden'); document.getElementById('disconnectBtn').classList.remove('hidden'); document.getElementById('authSection').classList.remove('hidden'); };
            socket.onclose = () => { log('Disconnected'); handleDisconnect(); };
            socket.onerror = () => log('Connection error', 'error');
            socket.onmessage = (e) => handleMessage(e.data);
        } catch (err) { log(`Error: ${err.message}`, 'error'); }
    }

    function disconnect() { if (socket) socket.close(); handleDisconnect(); }

    function handleDisconnect() {
        socket = null; isAuthenticated = false; currentRoom = null; gameRunning = false; myUsername = null;
        previousStates = {}; boardElements = {}; pendingGarbage = {};
        updateStatus('connectionStatus', 'disconnected', 'Disconnected');
        updateStatus('gameInfo', 'disconnected', 'Not in a room');
        document.getElementById('connectBtn').classList.remove('hidden');
        ['disconnectBtn', 'authSection', 'roomSection', 'startSection', 'scoreboard'].forEach(id => document.getElementById(id).classList.add('hidden'));
        document.getElementById('playersContainer').innerHTML = '';
    }

    function sendPacket(type, payload) {
        if (!socket || socket.readyState !== WebSocket.OPEN) { log('Not connected', 'error'); return; }
        socket.send(JSON.stringify({ type, payload }));
        if (!['LEFT', 'RIGHT', 'DOWN', 'DROP', 'ROTATE', 'HOLD'].includes(type)) log(`‚Üí ${type}`, 'sent');
    }

    function handleMessage(data) {
        try {
            const pkt = JSON.parse(data);
            if (pkt.type !== 'UPDATE') log(`‚Üê ${pkt.type}`, 'received');

            switch (pkt.type) {
                case 'AUTH_SUCCESS': handleAuthSuccess(pkt.payload); break;
                case 'SHOW_ROOMS': handleShowRooms(pkt.payload); break;
                case 'CREATE_SUCCESS': handleRoomJoined(pkt.payload); break;
                case 'JOIN_SUCCESS': handleJoinSuccess(pkt.payload); break;
                case 'JOIN': addChat('System', `üëã ${pkt.payload} joined`); break;
                case 'LEAVE': addChat('System', `üëã ${pkt.payload} left`); break;
                case 'START':
                    gameRunning = true; previousStates = {}; pendingGarbage = {};
                    updateStatus('gameInfo', 'playing', `Playing: ${currentRoom}`);
                    document.getElementById('startSection').classList.add('hidden');
                    document.getElementById('scoreboard').classList.remove('hidden');
                    addChat('System', 'üéÆ Game started!');
                    break;
                case 'UPDATE': handleGameUpdate(pkt.payload); break;
                case 'ATTACK': handleAttack(pkt.payload); break;
                case 'DEATH': addChat('System', `üíÄ ${pkt.payload} died!`); break;
                case 'WINNER':
                    gameRunning = false;
                    addChat('System', `üèÜ ${pkt.payload} wins!`);
                    updateStatus('gameInfo', 'waiting', `Ended: ${currentRoom}`);
                    document.getElementById('startSection').classList.remove('hidden');
                    break;
                case 'MESSAGE': addChatHtml('Server', typeof pkt.payload === 'object' ? pkt.payload.text : escapeHtml(String(pkt.payload))); break;
                default: if (pkt.type.includes('ERROR')) log(`Error: ${pkt.payload}`, 'error');
            }
        } catch (err) { log(`Parse error: ${err.message}`, 'error'); }
    }

    // FIXED: Attack affects ALL players except the attacker
    function handleAttack(payload) {
        const attacker = payload.attacker;
        const lines = payload.lines;

        addChatHtml('‚öîÔ∏è', `${escapeHtml(attacker)} sent ${lines} garbage to everyone!`, 'attack');

        // Apply to ALL players EXCEPT the attacker
        Object.entries(boardElements).forEach(([name, els]) => {
            if (name !== attacker) {
                pendingGarbage[name] = (pendingGarbage[name] || 0) + lines;

                // Shake
                els.boardWrapper.classList.add('shake');
                setTimeout(() => els.boardWrapper.classList.remove('shake'), 200);

                // Flash
                els.boardDiv.classList.add('attack-flash');
                setTimeout(() => els.boardDiv.classList.remove('attack-flash'), 300);

                // Float text
                showFloatText(els.boardWrapper, `+${lines} ‚öîÔ∏è`, 'attack');

                // Update indicator
                updateGarbageIndicator(els.garbageIndicator, pendingGarbage[name]);
            }
        });
    }

    function handleAuthSuccess(payload) {
        isAuthenticated = true;
        myUsername = typeof payload === 'object' ? payload.username : payload;
        log(`Logged in as: ${myUsername}`);
        document.getElementById('authSection').classList.add('hidden');
        document.getElementById('roomSection').classList.remove('hidden');
        showRooms();
    }

    function handleShowRooms(payload) {
        const div = document.getElementById('rooms'); div.innerHTML = '';
        if (!payload.rooms || !payload.rooms.length) { div.innerHTML = '<p style="color:#666;text-align:center;padding:8px;">No rooms</p>'; return; }
        payload.rooms.forEach(r => {
            const el = document.createElement('div'); el.className = 'room-item';
            el.innerHTML = `<span><b>${escapeHtml(r.id)}</b> ${r.count}/${r.max} ${r.running?'üéÆ':'‚è≥'}</span><button class="btn-primary" onclick="joinRoom('${escapeHtml(r.id)}')" ${r.running?'disabled style="opacity:0.5"':''}>Join</button>`;
            div.appendChild(el);
        });
    }

    function handleRoomJoined(roomId) { currentRoom = String(roomId); updateStatus('gameInfo', 'waiting', `Room: ${currentRoom}`); document.getElementById('startSection').classList.remove('hidden'); }
    function handleJoinSuccess(payload) { currentRoom = payload.roomId; updateStatus('gameInfo', 'waiting', `Room: ${payload.roomId} (${payload.currentPlayers}/${payload.maxPlayers})`); document.getElementById('startSection').classList.remove('hidden'); }

    function handleGameUpdate(payload) {
        if (!payload || !payload.states) return;

        const container = document.getElementById('playersContainer');
        const scoreboard = document.getElementById('scoreboard');
        const players = Object.entries(payload.states);
        const isCompact = players.length > 1;

        // Scoreboard
        const sorted = [...players].sort((a, b) => b[1].points - a[1].points);
        scoreboard.innerHTML = '';
        sorted.forEach(([name, state], idx) => {
            const entry = document.createElement('div');
            entry.className = 'scoreboard-entry' + (idx === 0 ? ' first' : '') + (state.alive ? '' : ' dead');
            entry.innerHTML = `<div class="name">${idx === 0 ? 'üëë ' : ''}${escapeHtml(name)}${state.alive ? '' : ' üíÄ'}</div><div class="score">${formatPoints(state.points)}</div>`;
            scoreboard.appendChild(entry);
        });

        // Rebuild if player count changed
        if (container.children.length !== players.length) {
            container.innerHTML = '';
            boardElements = {};
        }

        players.forEach(([name, state]) => {
            let els = boardElements[name];

            if (!els) {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-board' + (isCompact ? ' compact' : '');

                const nameDiv = document.createElement('div');
                nameDiv.className = 'player-name';
                playerDiv.appendChild(nameDiv);

                const scoreDiv = document.createElement('div');
                scoreDiv.className = 'player-score';
                playerDiv.appendChild(scoreDiv);

                const gameArea = document.createElement('div');
                gameArea.className = 'game-area';

                const leftPanel = document.createElement('div');
                leftPanel.className = 'side-panel';
                const holdBox = createPreviewBox('Hold');
                leftPanel.appendChild(holdBox);
                const pointsBox = document.createElement('div');
                pointsBox.className = 'stats-box';
                pointsBox.innerHTML = `<h4>Points</h4><div class="value">0</div>`;
                leftPanel.appendChild(pointsBox);
                gameArea.appendChild(leftPanel);

                const boardWrapper = document.createElement('div');
                boardWrapper.className = 'board-wrapper';
                const boardDiv = document.createElement('div');
                boardDiv.className = 'game-board';
                for (let i = 0; i < 200; i++) { const cell = document.createElement('div'); cell.className = 'cell'; boardDiv.appendChild(cell); }
                boardWrapper.appendChild(boardDiv);

                const garbageIndicator = document.createElement('div');
                garbageIndicator.className = 'garbage-indicator';
                garbageIndicator.innerHTML = '<div class="fill"></div><div class="count"></div>';
                boardWrapper.appendChild(garbageIndicator);

                gameArea.appendChild(boardWrapper);

                const rightPanel = document.createElement('div');
                rightPanel.className = 'side-panel';
                const nextBox = createPreviewBox('Next');
                rightPanel.appendChild(nextBox);
                gameArea.appendChild(rightPanel);

                playerDiv.appendChild(gameArea);
                container.appendChild(playerDiv);

                els = { playerDiv, boardDiv, boardWrapper, holdBox, nextBox, pointsBox, nameDiv, scoreDiv, garbageIndicator };
                boardElements[name] = els;
            }

            const prev = previousStates[name] || {};

            // Update name/score
            els.nameDiv.className = 'player-name' + (state.alive ? '' : ' dead');
            els.nameDiv.textContent = name + (state.alive ? '' : ' üíÄ');
            els.scoreDiv.textContent = `‚≠ê ${formatPoints(state.points)}`;

            // Points animation
            if (prev.points !== undefined && state.points > prev.points) {
                const diff = state.points - prev.points;
                els.pointsBox.classList.add('pop');
                setTimeout(() => els.pointsBox.classList.remove('pop'), 250);

                if (diff >= 800) showFloatText(els.boardWrapper, 'TETRIS!', 'tetris');
                else if (diff >= 100) showFloatText(els.boardWrapper, `+${diff}`, 'points');
            }
            els.pointsBox.querySelector('.value').textContent = formatPoints(state.points);

            // Clear pending garbage when it appears on board
            if (pendingGarbage[name] && prev.board) {
                let garbageApplied = false;
                for (let y = 15; y < 20 && !garbageApplied; y++) {
                    for (let x = 0; x < 10; x++) {
                        if (state.board[y][x] === 8 && (!prev.board[y] || prev.board[y][x] !== 8)) {
                            garbageApplied = true;
                            break;
                        }
                    }
                }
                if (garbageApplied) {
                    pendingGarbage[name] = 0;
                    updateGarbageIndicator(els.garbageIndicator, 0);
                }
            }

            updateBoard(els.boardDiv, state);
            updatePreviewBox(els.holdBox, state.holdPiece);
            updatePreviewBox(els.nextBox, state.nextPiece);

            previousStates[name] = JSON.parse(JSON.stringify(state));
        });
    }

    function updateBoard(boardDiv, state) {
        const cells = boardDiv.children;

        for (let y = 0; y < 20; y++) {
            for (let x = 0; x < 10; x++) {
                const idx = y * 10 + x;
                cells[idx].className = 'cell';
                if (state.board[y][x]) cells[idx].classList.add(`color-${state.board[y][x]}`);
            }
        }

        if (state.alive && state.shape) {
            let ghostY = state.cy;
            while (canPlace(state.shape, state.cx, ghostY + 1, state.board)) ghostY++;
            if (ghostY > state.cy) {
                state.shape.forEach(([dx, dy]) => {
                    const x = state.cx + dx, y = ghostY + dy;
                    if (x >= 0 && x < 10 && y >= 0 && y < 20 && !state.board[y][x]) {
                        cells[y * 10 + x].classList.add(`color-${state.colorId}`, 'ghost');
                    }
                });
            }
            state.shape.forEach(([dx, dy]) => {
                const x = state.cx + dx, y = state.cy + dy;
                if (x >= 0 && x < 10 && y >= 0 && y < 20) {
                    cells[y * 10 + x].className = `cell color-${state.colorId} current-piece`;
                }
            });
        }
    }

    function updateGarbageIndicator(indicator, count) {
        const fill = indicator.querySelector('.fill');
        const countEl = indicator.querySelector('.count');
        fill.style.height = Math.min(count * 5, 100) + '%';
        countEl.textContent = count > 0 ? count : '';
    }

    function showFloatText(container, text, type) {
        const float = document.createElement('div');
        float.className = `float-text ${type}`;
        float.textContent = text;
        container.appendChild(float);
        setTimeout(() => float.remove(), 700);
    }

    function createPreviewBox(title) {
        const box = document.createElement('div');
        box.className = 'preview-box';
        box.innerHTML = `<h4>${title}</h4>`;
        const grid = document.createElement('div');
        grid.className = 'preview-grid';
        for (let i = 0; i < 25; i++) { const cell = document.createElement('div'); cell.className = 'preview-cell'; grid.appendChild(cell); }
        box.appendChild(grid);
        return box;
    }

    function updatePreviewBox(box, pieceData) {
        const cells = box.querySelectorAll('.preview-cell');
        cells.forEach(c => c.className = 'preview-cell');
        if (pieceData && pieceData.shape && pieceData.colorId) {
            const dim = SHAPE_DIMENSIONS[pieceData.colorId] || 4;
            const off = Math.floor((5 - dim) / 2);
            pieceData.shape.forEach(([px, py]) => {
                const x = px + off, y = py + off;
                if (x >= 0 && x < 5 && y >= 0 && y < 5) cells[y * 5 + x].classList.add(`color-${pieceData.colorId}`);
            });
        }
    }

    function canPlace(shape, cx, cy, board) {
        for (const [dx, dy] of shape) {
            const x = cx + dx, y = cy + dy;
            if (x < 0 || x >= 10 || y >= 20) return false;
            if (y >= 0 && board[y][x] !== 0) return false;
        }
        return true;
    }

    function authenticate() { const u = document.getElementById('username').value.trim(); if (!u) return log('Enter username', 'error'); sendPacket('AUTH', { username: u }); }
    function showRooms() { sendPacket('SHOW_ROOMS', {}); }
    function createRoom() { sendPacket('CREATE_ROOM', { room_name: document.getElementById('roomName').value.trim() || 'Room', max_players: parseInt(document.getElementById('maxPlayers').value) || 4 }); }
    function joinRoom(id) { sendPacket('JOIN_ROOM', { roomId: id }); }
    function startGame() { sendPacket('CHAT', { content: '/start' }); }
    function sendInput(cmd) { if (!currentRoom || !gameRunning) return; sendPacket(cmd, {}); }
    function sendChat() { const input = document.getElementById('chatInput'); const msg = input.value.trim(); if (!msg) return; sendPacket('CHAT', { content: msg }); input.value = ''; }
    function addChat(sender, msg) { addChatHtml(escapeHtml(sender), escapeHtml(msg)); }
    function addChatHtml(sender, html, cls = '') {
        const div = document.getElementById('chatMessages');
        const el = document.createElement('div');
        el.className = 'chat-message' + (cls ? ' ' + cls : '');
        el.innerHTML = `<strong>${sender}:</strong> ${html}`;
        div.appendChild(el);
        div.scrollTop = div.scrollHeight;
        while (div.children.length > 50) div.removeChild(div.firstChild);
    }

    document.addEventListener('keydown', (e) => {
        if (!currentRoom || !gameRunning || e.target.tagName === 'INPUT') return;
        const map = { 'ArrowLeft': 'LEFT', 'ArrowRight': 'RIGHT', 'ArrowUp': 'ROTATE', 'ArrowDown': 'DOWN', ' ': 'DROP', 'c': 'HOLD', 'C': 'HOLD' };
        if (map[e.key]) { e.preventDefault(); sendInput(map[e.key]); }
    });
</script>
</body>
</html>